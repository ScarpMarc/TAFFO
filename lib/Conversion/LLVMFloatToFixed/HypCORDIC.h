#pragma once
#include "FixedPointType.h"
#include "LLVMFloatToFixedPass.h"
#include "TAFFOMath.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/InstIterator.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Intrinsics.h"

namespace flttofix
{
/**
 * @brief Handles the exp function.
 *
 * The exp is calculated with the CORDIC algorithm, and relies on the arctanh function which is stored in @ref arctanh_2power.
 * The calculation relies on a series of oscillations which, after some iterations, settle to the desider value.
 * The output is computed differently, depending on how we initialise the internal variables x and y: in our case, we chose to
 * initialise them to the same value, which leads to them ending up at the same value and thus we just return x.
 * The input argument also plays a role in that it oscillates to 0, and its sign is used to decide the sign of the
 * correction that is applied to the internal variables.
 *
 * The value at which we initialise these variables is the (1/An) compile-time constant calculated in @ref compute_An_inv(),
 * which in turn depends on how many range-adjustment iterations
 * we do, as stored in @ref cordic_exp_negative_iterations. This is because the original CORDIC algorithm works for an exponent in the range
 * of about [-1, 1], which is practically useless; the range can be extended by doing these "negative" iterations. We chose to do
 * 6 negative iterations for now, which can support an exponent up to about 15. Beware that the more negative iterations, the more
 * the constant (1/An) will explode in magnitude.
 *
 * Since these oscillations may be huge in magnitude, we need to use a larger fixed point type for the internal representation:
 * we use @ref cordic_exp_internal_width bits in total, with @ref cordic_exp_internal_width_fractional bits for the fractional part.
 * Note that we also need the enhanced precision because in case the exponent is negative, the VRA will allocate few bits for
 * the integer part; however, in these cases the intermediate results will still start at the same magnitude as the positive ones.
 * 
 * We chose to perform 64 (i.e. TaffoMath::TABLELENGHT) iterations in total; this amount includes the 6 negative ones. Should
 * someone decide to support larger exponents, they should remember to update @ref arctanh_2power along with the rest. See
 * the documentation for that array for more information.
 * 
 * !!! NOTE !!!
 * The textbook loop goes from -negative_iterations to 0 and then from 1 to positive_iterations. 
 * HOWEVER: we start from 0 go to total_iterations, reading everything from the same table. 
 * Please see the documentation for @ref arctanh_2power.
 *
 * We estimated we need 22 bits for the integer part + 1 for the sign for these internal values.
 */
bool createExp(FloatToFixed *ref, llvm::Function *newfs, llvm::Function *oldf);

/// Total number of iterations for the exp CORDIC algorithm
constexpr int cordic_exp_total_iterations = TaffoMath::TABLELENGHT;
/// The number of negative iterations for range expansion in the exp CORDIC algorithm
const int cordic_exp_negative_iterations = 6;
/// The number of positive iterations for the exp CORDIC algorithm
const int cordic_exp_positive_iterations = cordic_exp_total_iterations - cordic_exp_negative_iterations;
/// Width of the extended, internal representation for the exp CORDIC algorithm
const int cordic_exp_internal_width = 64;
/// Fractional part of the internal representation for the exp CORDIC algorithm. We estimate we need 22 bits for the integer part + 1 for the sign.
const int cordic_exp_internal_width_fractional = 64 - 23;
/// The constant e
const double e = 2.718281828459045235360287471352662497757247093699959574966967627724076630353547594571382178525166427;
/// The constant e^(-1)
const double e_inv = 0.3678794411714423215955237701614608674458111310317678345078368016974614957448998033571472743459196437;


/// Compute the 1/An constant for the exp CORDIC algorithm. Both m and n are expected to be positive.
constexpr double compute_An_inv(const int &m, const int &n)
{
  // From i = -m to 0
  double prod_1 = 1.0;
  for (int i = -m; i <= 0; ++i) {
    prod_1 *= std::sqrt(1.0 - std::pow(1 - std::pow(2.0, i - 2), 2));
  }

  double prod_2 = 1.0;
  for (int i = 1; i <= n; ++i) {
    prod_2 *= std::sqrt(1.0 - std::pow(2.0, -2 * i));
  }

  // Note: empirically, we found that the following makes the result less precise.
  // double prod_3 = std::sqrt(1.0 - std::pow(2.0, -2 * 4)) * std::sqrt(1.0 - std::pow(2.0, -2 * 40)) * std::sqrt(1.0 - std::pow(2.0, -2 * 4));

  // return 1.0 / (prod_1 * prod_2 * prod_3);
  return 1.0 / (prod_1 * prod_2);
}

/**
 * @brief Table for the exp CORDIC algorithm.
 * 
 * Each item in this array is calculated as follows: 
 * - for NEGATIVE ITERATIONS (i.e. from - @ref cordic_exp_negative_iterations to  to 0 INCLUSIVE), the value is arctanh(1-2^(-i-2)), i.e. in our case the first one is arctanh(1-2^(-6-2)) = arctanh(1-2^(-8))
 * - for POSITIVE ITERATIONS (i.e. from 1 to @ref cordic_exp_total_iterations), the value is arctanh(2^(-i)), i.e. in our case the first one is arctanh(2^(-1))
 * 
 * In case you need to add more negative iterations to support larger exponent, you MUST update the following table with the new values. The values we used are reported
 * for your convenience. Please also remember to update @ref cordic_exp_negative_iterations and @ref cordic_exp_positive_iterations accordingly.
 *
 * Both tables for the negative iterations (i.e. @ref cordic_exp_negative_iterations) and positive ones (i.e. @ref cordic_exp_positive_iterations) are stored in this array. This means that the first cordic_exp_negative_iterations+1 elements are for the negative iterations, and the rest are for the positive ones.
 *
 * This table is meant to be indexed consecutively, hence the iterator should not be reset.
 *
 * Values for negative values are needed for range expansion; they go up to m=-6, which is good for about an exponent of 15.544 instead of about 1.12 for the original algorithm.
 * 
 * Note that with 32 bits, the last values (how many, depends on the fixed point type of the ARGUMENT) will be discretised as 0. 
 * This is not a problem, as that means the successive damping iterations will be null; we are just wasting some cycles.
 */
const double arctanh_2power[TaffoMath::TABLELENGHT] = {
    // Values for negative iterations
    /* arctanh(1 - 2^-8) */ 3.118184795101852217098730800440861150270918787226729426527544503549684919336333280531993910711365211,
    /* arctanh(1 - 2^-7) */ 2.770631772579213073122769594010919939880647462338505980472289981496982928363599006207922250472207324,
    /* arctanh(1 - 2^-6) */ 2.422093543229295636523720403858146197436954561963042881453632603928592630868287688872947559801251667,
    /* arctanh(1 - 2^-5) */ 2.071567363195766343947921608644115569466032922613680045964389408606284224594643600767445004107667852,
    /* arctanh(1 - 2^-4) */ 1.716993602242573122964582162271178605224969465240295985878359036237490708298775616106932415668043315,
    /* arctanh(1 - 2^-3) */ 1.354025100551105032998002285074356672086545956045633586823671112555836640463133365751874816453455850,
    /* arctanh(1 - 2^-2) */ 0.9729550745276566525526763717215898648185423647909305942296950749687899313760346338938292492939357635,
    // Values for positive iterations
    /* arctanh 2^-1 */ 0.5493061443340548456976226184612628523237452789113747258673471668187471466093044834368078774068660444,
    /* arctanh 2^-2 */ 0.2554128118829953416027570481518309674390553982228841350889767789183423472445243988782590616397237610,
    /* arctanh 2^-3 */ 0.1256572141404530388425688652009358398289481930318188575049992586687043618425743329797865055197963253,
    /* arctanh 2^-4 */ 0.06258157147700300712676502386220659570755555024723880682494775638530964743733227470417261756529562397,
    /* ... */ 0.03126017849066699476401224517264889700962924063978732759827198514654325026714722386740281574014012481,
    0.01562627175205221137920177875163755269940172690068237320145729246253760292139037124740926665916669750,
    0.007812658951540420910323471276040172666358809389109552009557195351584102677510013832656316647613020782,
    0.003906269868396826053127563369707785926714952154966438549269931611585163947079132049446019490111067066,
    0.001953127483532549998650770886854175319006680156959160343477115111202871523678814135508913417102870457,
    0.0009765628104410358409644500298853262542384178477892393672892889826436290457880615300248017029462609311,
    0.0004882812888051128267610066262711604168892277082069321137806958020717180273252754365959509402218560490,
    0.0002441406298506385829279722521024436712638161729538473540838898718884917421927910267100564152395556489,
    0.0001220703131063298066029630787370893765950488685976220575203911646340786626569923485332455194776341683,
    0.00006103515632579122531715060972789098445439513193248287051073602149747278819469280129411145533770080035,
    0.00003051757813447390314876195840214273449250632814783497652879918431380828101676529706223499048032126281,
    0.00001525878906368423789309893643232332593252929012133175343880097004879029645246466784506120386487026744,
    0.000007629394531398029736621857417551822259585168152661468555920615941193317259069681442278378808424702192,
    0.000003814697265643503717077247501053784803630239378064127173696795195632912450620386871438743811974720491,
    0.000001907348632814812964634640791502342660236767104749725717162909750412542736136512885500621683984176570,
    0.0000009536743164065391205793296256212496983850880401927809597468355899738309425621134351599726286988554803,
    0.0000004768371582031611400724161884115142393921535238599653818506354689240616058526602310832981335142648965,
    0.0000002384185791015670175090520230892160932709887487983249122290761708315768215284598314352905928958611214,
    0.0000001192092895507818146886315028717075370759685916006931541372667959741042013096116381894887430546278058,
    0.00000005960464477539069558607893785851205230378030981967369923923643930968219432059665194692992724885825675,
    0.00000002980232238769532132325986723229990060576267123261864264303930424591915949407520598352649862617181254,
    0.00000001490116119384765735290748340403704676533877554591227217196424776397793297417444913879858590477331712,
    0.000000007450580596923828262863435425504617070342923244554568998159436907192708439693875004142928268316332986,
    0.000000003725290298461914079732929428188076703313977164985495600947820388535746995138910864212327575114897691,
    0.000000001862645149230957033404116178523509574461781888104942902562764320560333040723976348563163870135559775,
    0.0000000009313225746154785158942645223154386963873331967156727402409773742360086730774616696225463462546236132,
    0.0000000004656612873077392578461580652894298370352794764864139324800383843514154788815737699407971919086561945,
    0.0000000002328306436538696289104572581611787296289993979013315803086781286536291653567595230362843624488559169,
    0.0000000001164153218269348144536509072701473412036120954670580049994826705458101990105856850325505459565088269,
    0.00000000005820766091346740722662823840876841765045111101867573679558840788649955278258833427310111544924799954,
    0.00000000002910383045673370361328946730109605220630637634874988854228145966414731175203775785324471878479108374,
    0.00000000001455191522836685180664165216263700652578829665207546798787371085510467020600862828814371176246721826,
    0.000000000007275957614183425903320440895329625815723537069274487620986980369303969061460651571410766384991681521,
    0.000000000003637978807091712951660172299416203226965442133276968893951583999676046764878999360758953249398019039,
    0.000000000001818989403545856475830080131177025403370680266647672922410454607881789101436466056144142688769450642,
    0.0000000000009094947017729282379150393132721281754213350333305857343846351574827949927332833946775762242219938997,
    0.0000000000004547473508864641189575195625965160219276668791663115486444334050446484789629420236729489978928699015,
    0.0000000000002273736754432320594787597695433145027409583598957885789507527384543091568977972770695826766873639847,
    0.0000000000001136868377216160297393798833022893128426197949869735609741627973950301476443334101850493961929165232,
    0.00000000000005684341886080801486968994146747366410532747437337169476568655920838631542529508705538356363670455777,
    0.00000000000002842170943040400743484497071077795801316593429667146183458320144898602527096668006517710333945315829,
    0.00000000000001421085471520200371742248535251911975164574178708393272897516210449630740395848482712624262262349639,
    0.000000000000007105427357601001858711242675900827468955717723385491591111028448167446370653799660239755570734634112,
    0.000000000000003552713678800500929355621337905572183619464715423186448888538968055474794617943365556545846283206139,
    0.000000000000001776356839400250464677810668947180897952433089427898306111056758883013849273687245945399102061698034,
    0.0000000000000008881784197001252323389053344728897997440541361784872882638817632315042155325372909072633552880506785,
    0.0000000000000004440892098500626161694526672363573187180067670223109110329852100405357608282336108997856840432274897,
    0.0000000000000002220446049250313080847263336181677117147508458777888638791231509312106492874875279104850156503314261,
    0.0000000000000001110223024625156540423631668090824874018438557347236079848903938562808211354346386934359958670717645,
    0.00000000000000005551115123125782702118158340454107264398048196684045099811129923171883670363241413994904226184586651,
    0.00000000000000002775557561562891351059079170227051493987256024585505637476391240395497127738227315197080349455766764,
    0.00000000000000001387778780781445675529539585113525479717157003073188204684548905049406255621741606226126209968930015,
    0.000000000000000006938893903907228377647697925567627064490196253841485255855686131311748167856696755228436251925837260};
} // namespace flttofix